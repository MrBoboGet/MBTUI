(import text)
(defclass TMLElement ()
    (attributes (dict))
    (children (list))
)

(defclass Attribute ()
    (name "")
    (value null)
    (mandatory true)
)
(defclass Header ()
    (name "")
    (attributes (dict))
)

(defclass Element ()
    (header (Header))
    (children (list))
)
(defclass Text (Element)
    (content "")
    (constructor (str)
        (set :content this str)
        (set :name :header this "raw-text")
    )
)
(setl idf-regex (regex "\\w"))
(defun parse-idf (stream)
    (setl ret "")
    (while (not (eof stream))
        (if (matching idf-regex (peek-byte stream))
            (append ret (read-byte stream))
        else
            (break)
        )
    )
    ret
)

(defun parse-element (stream)
    #assumes that it start on the byte after <
    (setl ret (Element))
    (set :header ret (parse-header stream))
    (while (not (eof stream))
        (setl text-content (read-until stream "<"))
        (if (not (is-whitespace text-content))
            (append :children ret (Text text-content))
        )
        (if (eq (peek-byte stream) "/")
            (read-byte stream)
            (setl end-name (parse-idf stream))
            (skip-whitespace stream)
            (if (not (eq (peek-byte stream) ">"))
                (error "Close tag needs >")
            )
            (read-byte stream)
            (if (eq end-name :name :header ret)
                (break)
            )
        )
        (append :children ret (parse-element stream))
    )
    ret
)

(defun parse-header (stream)
    #assumes that it start on the byte after <
    (setl ret (Header))
    (set :name ret (parse-idf stream))
    (while (not (eof stream))
        (setl atr (Attribute))
        (skip-whitespace stream)
        (if (eq (peek-byte stream) "/")
            (read-byte stream)
            (if (not (eq (peek-byte stream) ">"))
                (error "Invalid character after '/' in header: "+(peek-byte stream))
            )
            (read-byte)
            (break)
        )
        (if (eq (peek-byte stream) ">")
            (read-byte stream)
            (break)
        )
        (set :name atr (parse-idf stream))
        (skip-whitespace stream)
        (if (eq (peek-byte stream) "=")
            (read-byte stream)
            (setl :value atr (parse-idf stream))
            (setl :mandatory atr false)
          else
            (setl :mandatory atr true)
        )
        (set ;:name atr :attributes ret atr)
    )
    ret
)
(defmethod str-mul (str count)
    (setl ret "")
    (dotimes count
        (append ret str)
    )
    ret
)
(defmethod str_impl ((el Element) depth)
    (setl padding (str-mul "    " depth))
    (setl ret (copy padding))
    (incr ret :name :header el)
    (doit key (keys :attributes :header el)
        (setl atr ;key :attributes :header el)
        (append ret " ")
        (append ret :name atr)
        (if (not (eq :value atr null))
            (append ret "=")
            (append  ret (str :value atr))
        )
    )
    (doit child :children el
        (append ret "\n")
        (append ret (str_impl child (+ depth 1)))
    )
    ret
)
(defmethod str ((el Element))
    (setl ret (str_impl el 0))
    ret
)
(defun parse-tml (stream)
    (setl return-value null)
    (skip-whitespace stream)
    (if (not (eq (peek-byte stream) "<"))
        (error "TML must start with '<'")
    )
    (read-byte stream)
    (setl return-value (parse-element stream))
    (return return-value)
)
(set stream (open "TestMarkup.tml" "r")) 
(print (str (parse-tml stream)))
(print (read-line stream))
