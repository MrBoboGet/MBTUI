(import text)
(defclass TMLElement ()
    (attributes (dict))
    (children (list))
    (set-children (children)
        (setl :children this children)
    )
)

(defclass Attribute ()
    (name "")
    (value null)
    (mandatory true)
    (is-parameter-value true)
)
(defclass Header ()
    (name "")
    (attributes (dict))
)

(defclass Element ()
    (header (Header))
    (children (list))
)
(defclass Text (Element)
    (content "")
    (constructor (str)
        (set :content this str)
        (set :name :header this "raw-text")
    )
)
(setl idf-regex (regex "\\w"))
(defun parse-idf (stream)
    (setl ret "")
    (while (not (eof stream))
        (if (matching idf-regex (peek-byte stream))
            (append ret (read-byte stream))
        else
            (break)
        )
    )
    ret
)

(defun parse-element (stream)
    #assumes that it start on the byte after <
    (setl ret (Element))
    (set :header ret (parse-header stream))
    (while (not (eof stream))
        (setl text-content (read-until stream "<"))
        (if (not (is-whitespace text-content))
            (append :children ret (Text text-content))
        )
        (if (eq (peek-byte stream) "/")
            (read-byte stream)
            (setl end-name (parse-idf stream))
            (skip-whitespace stream)
            (if (not (eq (peek-byte stream) ">"))
                (error "Close tag needs >")
            )
            (read-byte stream)
            (if (eq end-name :name :header ret)
                (break)
            )
        )
        (append :children ret (parse-element stream))
    )
    ret
)

(defun parse-header (stream)
    #assumes that it start on the byte after <
    (setl ret (Header))
    (set :name ret (parse-idf stream))
    (while (not (eof stream))
        (setl atr (Attribute))
        (skip-whitespace stream)
        (if (eq (peek-byte stream) "/")
            (read-byte stream)
            (if (not (eq (peek-byte stream) ">"))
                (error (+ "Invalid character after '/' in header: " (peek-byte stream)))
            )
            (read-byte stream)
            (break)
        )
        (if (eq (peek-byte stream) ">")
            (read-byte stream)
            (break)
        )
        (set :name atr (parse-idf stream))
        (skip-whitespace stream)
        (if (eq (peek-byte stream) "=")
            (read-byte stream)
            #(setl :value atr (read-term stream))
            (skip-whitespace stream)
            (if (matching idf-regex (peek-byte stream))
                (setl :value atr (parse-idf stream))
             else 
                (if (eq (peek-byte stream) "@") (read-byte stream))
                (setl :value atr (read-term stream))
                (setl :is-parameter-value atr false)
            )
            (setl :mandatory atr false)
          else
            (setl :mandatory atr true)
        )
        (set ;:name atr :attributes ret atr)
    )
    ret
)
(defmethod str-mul (str count)
    (setl ret "")
    (dotimes count
        (append ret str)
    )
    ret
)
(defmethod str_impl ((el Element) depth)
    (setl padding (str-mul "    " depth))
    (setl ret (copy padding))
    (incr ret :name :header el)
    (doit key (keys :attributes :header el)
        (setl atr ;key :attributes :header el)
        (append ret " ")
        (append ret :name atr)
        (if (not (eq :value atr null))
            (append ret "=")
            (append  ret (str :value atr))
        )
    )
    (doit child :children el
        (append ret "\n")
        (append ret (str_impl child (+ depth 1)))
    )
    ret
)
(defmethod str ((el Element))
    (setl ret (str_impl el 0))
    ret
)
(defmethod convert-child ((el Element))
    (setl ret null)
    (setl atrs :attributes :header el)
    (setl attributes-sym (gensym))
    (setl child-sym (gensym))
    `(progn (setl ,attributes-sym 
        (make-dict ,(map _(cond :is-parameter-value ;_ atrs `(,_ (index current-params ,_) ) `(_ :value ;_ atrs )) (keys atrs)  )))
        (let ((,child-list (list)))
            ,@(map convert-child :children el)
            (setl ,child-sym ,child-list)
        )
        (append ,child-list (,(symbol :name :header el) ,attributes-sym ,child-sym  ))
     )
)

(set child-list (dynamic (list)))
(defmethod convert-element ((el Element))
    (setl ret false)
    (setl atrs :attributes :header el)
    (setl class-def 
    `(defclass ,:name :header el (,TMLElement)
        (constructor (params children)
            (setl current-params (copy params))
            (setl children (list))
            ,@(map (lambda (atr) 
                (if :mandatory ;atr atrs
                    `(if (not (in ,atr current-params ))
                        (error ,(+ "Missing mandatory attribute for " :name :header el " '" atr "'"))
                     )
                 else
                    `(if (not (in ,atr current-params ))
                        (set (index current-params ,atr) ,:value ;atr atrs)
                     )
                )
                ) (keys :attributes :header el))
            (let ((,child-list (list)))
            ,@(map convert-child :children el)
              (setl :children this ,child-list)
            )
        )
    ))
)


(defun parse-tml (stream)
    (setl return-value null)
    (skip-whitespace stream)
    (if (not (eq (peek-byte stream) "<"))
        (error "TML must start with '<'")
    )
    (read-byte stream)
    (setl return-value (parse-element stream))
    (return return-value)
)
(set stream (open "TestMarkup.tml" "r")) 
(setl tml (parse-tml stream))
(print (str tml)) 
(print (convert-element tml))
(print (read-line stream))
